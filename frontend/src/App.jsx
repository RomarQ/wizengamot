import { useState, useEffect, useCallback, useMemo } from 'react';
import Sidebar from './components/Sidebar';
import ChatInterface from './components/ChatInterface';
import ConfigModal from './components/ConfigModal';
import SettingsModal from './components/SettingsModal';
import PromptManager from './components/PromptManager';
import CommentModal from './components/CommentModal';
import CommitSidebar from './components/CommitSidebar';
import ModeSelector from './components/ModeSelector';
import SynthesizerInterface from './components/SynthesizerInterface';
import MonitorInterface from './components/MonitorInterface';
import SearchModal from './components/SearchModal';
import { api } from './api';
import { SelectionHandler } from './utils/SelectionHandler';
import { buildHighlightsText, buildContextStackText } from './utils/tokenizer';
import { useTheme } from './contexts/ThemeContext';
import './App.css';

function App() {
  const { theme, toggleTheme } = useTheme();
  const [conversations, setConversations] = useState([]);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [currentConversation, setCurrentConversation] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [showConfigModal, setShowConfigModal] = useState(false);
  const [showSettingsModal, setShowSettingsModal] = useState(false);
  const [showPromptManager, setShowPromptManager] = useState(false);
  const [showModeSelector, setShowModeSelector] = useState(false);
  const [availableConfig, setAvailableConfig] = useState(null);
  const [pendingCouncilConfig, setPendingCouncilConfig] = useState(null);

  // Monitor state
  const [monitors, setMonitors] = useState([]);
  const [currentMonitorId, setCurrentMonitorId] = useState(null);
  const [currentMonitor, setCurrentMonitor] = useState(null);

  // Comment and thread state
  const [comments, setComments] = useState([]);
  const [currentSelection, setCurrentSelection] = useState(null);
  const [commentButtonPosition, setCommentButtonPosition] = useState(null);
  const [showCommentModal, setShowCommentModal] = useState(false);
  const [showCommitSidebar, setShowCommitSidebar] = useState(false);
  const [showContextPreview, setShowContextPreview] = useState(false);
  const [activeCommentId, setActiveCommentId] = useState(null);
  const [contextSegments, setContextSegments] = useState([]);

  // Sidebar collapse states
  const [leftSidebarCollapsed, setLeftSidebarCollapsed] = useState(false);

  // Search modal state
  const [showSearchModal, setShowSearchModal] = useState(false);

  // Title animation state
  const [animatingTitleId, setAnimatingTitleId] = useState(null);

  // Prompt labels for sidebar display
  const [promptLabels, setPromptLabels] = useState({});

  const getModelShortName = useCallback((model) => {
    return model?.split('/')[1] || model;
  }, []);

  const autoContextSegments = useMemo(() => {
    if (!comments || comments.length === 0) {
      return [];
    }

    const seenKeys = new Set();
    const segments = [];

    comments.forEach((comment) => {
      if (!comment?.source_content) {
        return;
      }

      // Determine source type - check for note_id as fallback detection
      const sourceType = comment.source_type || (comment.note_id ? 'synthesizer' : 'council');

      // Build unique key based on source type
      const key = sourceType === 'council'
        ? `council-${comment.message_index}-${comment.stage}-${comment.model}`
        : `synth-${comment.note_id}`;

      // Check if already manually added or seen
      const manualExists = contextSegments.some((seg) => {
        if (sourceType === 'council') {
          return seg.messageIndex === comment.message_index &&
                 seg.stage === comment.stage &&
                 seg.model === comment.model;
        }
        return seg.noteId === comment.note_id;
      });

      if (manualExists || seenKeys.has(key)) {
        return;
      }

      seenKeys.add(key);

      if (sourceType === 'council') {
        segments.push({
          id: `auto-${key}`,
          sourceType: 'council',
          stage: comment.stage,
          model: comment.model,
          messageIndex: comment.message_index,
          label: `Stage ${comment.stage} â€¢ ${getModelShortName(comment.model)}`,
          content: comment.source_content,
          autoGenerated: true,
        });
      } else {
        // Synthesizer
        segments.push({
          id: `auto-${key}`,
          sourceType: 'synthesizer',
          noteId: comment.note_id,
          noteTitle: comment.note_title,
          sourceUrl: comment.source_url,
          noteModel: comment.note_model,
          label: comment.note_title || 'Note',
          content: comment.source_content,
          autoGenerated: true,
        });
      }
    });

    return segments;
  }, [comments, contextSegments, getModelShortName]);

  // Load conversations, monitors, config, and prompt labels on mount
  useEffect(() => {
    loadConversations();
    loadMonitors();
    loadConfig();
    loadPromptLabels();
  }, []);

  // Global keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.metaKey || e.ctrlKey) {
        if (e.key === 'k') {
          e.preventDefault();
          setShowSearchModal(s => !s);
        } else if (e.key === '/') {
          e.preventDefault();
          setLeftSidebarCollapsed(c => !c);
        } else if (e.key === 'd') {
          e.preventDefault();
          handleNewConversation();
        }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  const loadConfig = async () => {
    try {
      const config = await api.getConfig();
      setAvailableConfig(config);
    } catch (error) {
      console.error('Failed to load config:', error);
    }
  };

  const loadPromptLabels = async () => {
    try {
      const labels = await api.getPromptLabels();
      setPromptLabels(labels);
    } catch (error) {
      console.error('Failed to load prompt labels:', error);
    }
  };

  // Load conversation details when selected
  useEffect(() => {
    if (currentConversationId) {
      loadConversation(currentConversationId);
      loadComments(currentConversationId);
    } else {
      setComments([]);
      setActiveCommentId(null);
      setContextSegments([]);
    }
  }, [currentConversationId]);

  const loadConversations = async () => {
    try {
      const convs = await api.listConversations();
      setConversations(convs);
    } catch (error) {
      console.error('Failed to load conversations:', error);
    }
  };

  const loadMonitors = async () => {
    try {
      const mons = await api.listMonitors();
      setMonitors(mons);
    } catch (error) {
      console.error('Failed to load monitors:', error);
    }
  };

  const loadMonitor = async (id) => {
    try {
      const mon = await api.getMonitor(id);
      setCurrentMonitor(mon);
    } catch (error) {
      console.error('Failed to load monitor:', error);
    }
  };

  const loadConversation = async (id) => {
    try {
      const conv = await api.getConversation(id);

      // Convert persisted threads to follow-up messages for display
      if (conv.threads && conv.threads.length > 0) {
        const threadMessages = [];
        conv.threads.forEach(thread => {
          thread.messages.forEach(msg => {
            if (msg.role === 'user') {
              threadMessages.push({
                role: 'follow-up-user',
                content: msg.content,
                model: thread.model,
                thread_id: thread.id,
                comments: [],
                context_segments: thread.context?.context_segments || [],
              });
            } else if (msg.role === 'assistant') {
              threadMessages.push({
                role: 'follow-up-assistant',
                content: msg.content,
                model: thread.model,
                thread_id: thread.id,
                loading: false,
              });
            }
          });
        });
        conv.messages = [...conv.messages, ...threadMessages];
      }

      setCurrentConversation(conv);
    } catch (error) {
      console.error('Failed to load conversation:', error);
    }
  };

  const handleNewConversation = () => {
    setShowModeSelector(true);
  };

  const handleModeSelect = async (mode) => {
    setShowModeSelector(false);

    if (mode === 'council') {
      // Show council config modal for model selection
      setShowConfigModal(true);
    } else if (mode === 'synthesizer') {
      // Create synthesizer conversation directly
      try {
        const newConv = await api.createConversation(null, null, 'synthesizer', null);
        setConversations([
          { id: newConv.id, created_at: newConv.created_at, message_count: 0, title: newConv.title, mode: 'synthesizer' },
          ...conversations,
        ]);
        setCurrentConversationId(newConv.id);
        setCurrentMonitorId(null);
        setCurrentMonitor(null);
      } catch (error) {
        console.error('Failed to create synthesizer conversation:', error);
      }
    } else if (mode === 'monitor') {
      // Create monitor directly
      try {
        const newMonitor = await api.createMonitor('New Monitor');
        setMonitors([
          { id: newMonitor.id, name: newMonitor.name, created_at: newMonitor.created_at, competitor_count: 0 },
          ...monitors,
        ]);
        setCurrentMonitorId(newMonitor.id);
        setCurrentMonitor(newMonitor);
        setCurrentConversationId(null);
        setCurrentConversation(null);
      } catch (error) {
        console.error('Failed to create monitor:', error);
      }
    }
  };

  const handleConfigSubmit = async (config) => {
    // Store the config and proceed to prompt selection
    setPendingCouncilConfig(config);
    setShowConfigModal(false);
    setShowPromptManager(true);
  };

  const handlePromptSelect = async (systemPrompt) => {
    try {
      const newConv = await api.createConversation(pendingCouncilConfig, systemPrompt, 'council', null);
      setConversations([
        { id: newConv.id, created_at: newConv.created_at, message_count: 0, title: newConv.title, mode: 'council' },
        ...conversations,
      ]);
      setCurrentConversationId(newConv.id);
      setShowPromptManager(false);
      setPendingCouncilConfig(null);
    } catch (error) {
      console.error('Failed to create conversation:', error);
    }
  };

  const handleSelectConversation = (id) => {
    // Clear monitor selection when selecting a conversation
    setCurrentMonitorId(null);
    setCurrentMonitor(null);
    setCurrentConversationId(id);
    setActiveCommentId(null);
    setContextSegments([]);
  };

  const handleDeleteConversation = async (id) => {
    try {
      await api.deleteConversation(id);
      setConversations(conversations.filter(c => c.id !== id));
      if (currentConversationId === id) {
        setCurrentConversationId(null);
        setCurrentConversation(null);
      }
    } catch (error) {
      console.error('Failed to delete conversation:', error);
    }
  };

  // Monitor handlers
  const handleSelectMonitor = async (id) => {
    // Clear conversation selection when selecting a monitor
    setCurrentConversationId(null);
    setCurrentConversation(null);
    setCurrentMonitorId(id);
    try {
      const monitor = await api.getMonitor(id);
      setCurrentMonitor(monitor);
    } catch (error) {
      console.error('Failed to load monitor:', error);
    }
  };

  const handlePauseMonitor = async (id) => {
    try {
      await api.pauseMonitor(id);
      loadMonitors();
      if (currentMonitorId === id) {
        const monitor = await api.getMonitor(id);
        setCurrentMonitor(monitor);
      }
    } catch (error) {
      console.error('Failed to pause monitor:', error);
    }
  };

  const handleResumeMonitor = async (id) => {
    try {
      await api.resumeMonitor(id);
      loadMonitors();
      if (currentMonitorId === id) {
        const monitor = await api.getMonitor(id);
        setCurrentMonitor(monitor);
      }
    } catch (error) {
      console.error('Failed to resume monitor:', error);
    }
  };

  const handleDeleteMonitor = async (id) => {
    try {
      await api.deleteMonitor(id);
      setMonitors(monitors.filter(m => m.id !== id));
      if (currentMonitorId === id) {
        setCurrentMonitorId(null);
        setCurrentMonitor(null);
      }
    } catch (error) {
      console.error('Failed to delete monitor:', error);
    }
  };

  const handleMarkMonitorRead = async (id) => {
    try {
      await api.markMonitorRead(id);
      // Update the monitors list to reflect the change
      setMonitors(monitors.map(m =>
        m.id === id ? { ...m, unread_updates: 0 } : m
      ));
    } catch (error) {
      console.error('Failed to mark monitor as read:', error);
    }
  };

  const handleSendMessage = async (content) => {
    if (!currentConversationId) return;

    setIsLoading(true);
    try {
      // Optimistically add user message to UI
      const userMessage = { role: 'user', content };
      setCurrentConversation((prev) => ({
        ...prev,
        messages: [...prev.messages, userMessage],
      }));

      // Create a partial assistant message that will be updated progressively
      const assistantMessage = {
        role: 'assistant',
        stage1: null,
        stage2: null,
        stage3: null,
        metadata: null,
        loading: {
          stage1: false,
          stage2: false,
          stage3: false,
        },
      };

      // Add the partial assistant message
      setCurrentConversation((prev) => ({
        ...prev,
        messages: [...prev.messages, assistantMessage],
      }));

      // Send message with streaming
      await api.sendMessageStream(currentConversationId, content, (eventType, event) => {
        switch (eventType) {
          case 'stage1_start':
            setCurrentConversation((prev) => {
              if (!prev?.messages?.length) return prev;
              const messages = [...prev.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg?.loading) lastMsg.loading.stage1 = true;
              return { ...prev, messages };
            });
            break;

          case 'stage1_complete':
            setCurrentConversation((prev) => {
              if (!prev?.messages?.length) return prev;
              const messages = [...prev.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg) {
                lastMsg.stage1 = event.data;
                if (lastMsg.loading) lastMsg.loading.stage1 = false;
              }
              return { ...prev, messages };
            });
            break;

          case 'stage2_start':
            setCurrentConversation((prev) => {
              if (!prev?.messages?.length) return prev;
              const messages = [...prev.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg?.loading) lastMsg.loading.stage2 = true;
              return { ...prev, messages };
            });
            break;

          case 'stage2_complete':
            setCurrentConversation((prev) => {
              if (!prev?.messages?.length) return prev;
              const messages = [...prev.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg) {
                lastMsg.stage2 = event.data;
                lastMsg.metadata = event.metadata;
                if (lastMsg.loading) lastMsg.loading.stage2 = false;
              }
              return { ...prev, messages };
            });
            break;

          case 'stage3_start':
            setCurrentConversation((prev) => {
              if (!prev?.messages?.length) return prev;
              const messages = [...prev.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg?.loading) lastMsg.loading.stage3 = true;
              return { ...prev, messages };
            });
            break;

          case 'stage3_complete':
            setCurrentConversation((prev) => {
              if (!prev?.messages?.length) return prev;
              const messages = [...prev.messages];
              const lastMsg = messages[messages.length - 1];
              if (lastMsg) {
                lastMsg.stage3 = event.data;
                if (lastMsg.loading) lastMsg.loading.stage3 = false;
              }
              return { ...prev, messages };
            });
            break;

          case 'title_complete':
            // Update conversations list with the new title directly
            setConversations(prev => prev.map(conv =>
              conv.id === currentConversationId
                ? { ...conv, title: event.data.title }
                : conv
            ));
            // Trigger title animation
            setAnimatingTitleId(currentConversationId);
            break;

          case 'complete':
            // Stream complete, reload conversations list
            loadConversations();
            setIsLoading(false);
            break;

          case 'error':
            console.error('Stream error:', event.message);
            setIsLoading(false);
            break;

          default:
            console.log('Unknown event type:', eventType);
        }
      });
    } catch (error) {
      console.error('Failed to send message:', error);
      // Remove optimistic messages on error
      setCurrentConversation((prev) => ({
        ...prev,
        messages: prev.messages.slice(0, -2),
      }));
      setIsLoading(false);
    }
  };

  // Comment and thread handlers
  const loadComments = async (conversationId) => {
    try {
      const loadedComments = await api.getComments(conversationId);
      setComments(loadedComments);
    } catch (error) {
      console.error('Failed to load comments:', error);
    }
  };

  const handleSelectionChange = useCallback((selection) => {
    if (selection) {
      setCurrentSelection(selection);
      // Position the comment button near the selection
      const rect = selection.range.getBoundingClientRect();
      setCommentButtonPosition({
        x: rect.right + 10,
        y: rect.top,
      });
    } else {
      setCurrentSelection(null);
      setCommentButtonPosition(null);
    }
  }, []);

  const handleCommentButtonClick = () => {
    setShowCommentModal(true);
    setCommentButtonPosition(null);
    // Don't clear currentSelection here - the modal needs it
  };

  const handleSaveComment = async (commentText) => {
    if (!currentSelection || !currentConversationId) return;

    try {
      const isCouncil = currentSelection.sourceType === 'council' || !currentSelection.sourceType;

      const commentData = {
        selection: currentSelection.text,
        content: commentText,
        sourceType: currentSelection.sourceType || 'council',
        sourceContent: currentSelection.sourceContent,
      };

      // Add source-type specific fields
      if (isCouncil) {
        commentData.messageIndex = currentSelection.messageIndex;
        commentData.stage = currentSelection.stage;
        commentData.model = currentSelection.model;
      } else {
        // synthesizer
        commentData.noteId = currentSelection.noteId;
        commentData.noteTitle = currentSelection.noteTitle;
        commentData.sourceUrl = currentSelection.sourceUrl;
        commentData.noteModel = currentSelection.noteModel;
      }

      const newComment = await api.createComment(currentConversationId, commentData);

      setComments([...comments, newComment]);
      setShowCommentModal(false);
      setCurrentSelection(null);
      setCommentButtonPosition(null);
      SelectionHandler.clearSelection();

      // Auto-open sidebar when first comment is added
      if (comments.length === 0) {
        setShowCommitSidebar(true);
      }
    } catch (error) {
      console.error('Failed to save comment:', error);
    }
  };

  const handleEditComment = async (commentId, newContent) => {
    if (!currentConversationId) return;

    try {
      const updatedComment = await api.updateComment(currentConversationId, commentId, newContent);
      setComments(comments.map(c => c.id === commentId ? updatedComment : c));
    } catch (error) {
      console.error('Failed to edit comment:', error);
    }
  };

  const handleDeleteComment = async (commentId) => {
    if (!currentConversationId) return;

    try {
      await api.deleteComment(currentConversationId, commentId);
      setComments(comments.filter((c) => c.id !== commentId));

      // Clear active comment if it was deleted
      if (activeCommentId === commentId) {
        setActiveCommentId(null);
      }

      // Also remove the highlight from DOM
      SelectionHandler.removeHighlight(commentId);
    } catch (error) {
      console.error('Failed to delete comment:', error);
    }
  };

  // Direct comment save handler (for keyboard-triggered comments in NoteViewer)
  const handleSaveCommentDirect = async (selection, commentText) => {
    if (!selection || !currentConversationId) return;

    try {
      const commentData = {
        selection: selection.text,
        content: commentText,
        sourceType: 'synthesizer',
        sourceContent: selection.sourceContent,
        noteId: selection.noteId,
        noteTitle: selection.noteTitle,
        sourceUrl: selection.sourceUrl,
        noteModel: selection.noteModel,
      };

      const newComment = await api.createComment(currentConversationId, commentData);
      setComments([...comments, newComment]);

      // Auto-open sidebar when first comment is added
      if (comments.length === 0) {
        setShowCommitSidebar(true);
      }
    } catch (error) {
      console.error('Failed to save comment:', error);
    }
  };

  const handleAddContextSegment = useCallback((segment) => {
    setContextSegments((prev) => {
      if (prev.some((item) => item.id === segment.id)) {
        return prev;
      }
      const updated = [...prev, segment];
      if (updated.length === 1 && !showCommitSidebar) {
        setShowCommitSidebar(true);
      }
      return updated;
    });
  }, [showCommitSidebar]);

  const handleRemoveContextSegment = useCallback((segmentId) => {
    setContextSegments((prev) => prev.filter((segment) => segment.id !== segmentId));
  }, []);

  const handleToggleCommitSidebar = () => {
    setShowCommitSidebar(!showCommitSidebar);
  };

  const handleSelectComment = (commentId) => {
    // Find the comment to get its stage and model
    const comment = comments.find(c => c.id === commentId);
    if (!comment) return;
    
    // Set active comment - this will trigger the ResponseWithComments to show it
    setActiveCommentId(commentId);
    
    // Dispatch custom event to switch tabs if needed
    window.dispatchEvent(new CustomEvent('switchToComment', { 
      detail: { stage: comment.stage, model: comment.model } 
    }));
    
    // Small delay to allow tab switch, then scroll to highlight
    setTimeout(() => {
      const highlight = document.querySelector(`[data-comment-id="${commentId}"]`);
      if (highlight) {
        highlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
        highlight.classList.add('pulse');
        setTimeout(() => highlight.classList.remove('pulse'), 1000);
      }
    }, 100);
  };

  const handleSetActiveComment = useCallback((commentId) => {
    setActiveCommentId(commentId);
  }, []);

  const handleCommitAndStartThread = async (model, question) => {
    if (!currentConversationId || (comments.length === 0 && contextSegments.length === 0 && autoContextSegments.length === 0)) return;

    setIsLoading(true);

    try {
      const commentIds = comments.map((c) => c.id);
      const isSynthesizerMode = currentConversation?.mode === 'synthesizer';

      // Build segment keys differently based on mode
      const manualSegmentKeys = new Set(
        contextSegments.map((segment) =>
          segment.sourceType === 'synthesizer'
            ? `synth-${segment.noteId}`
            : `${segment.messageIndex}-${segment.stage}-${segment.model}`
        )
      );

      const combinedSegments = [
        ...contextSegments,
        ...autoContextSegments.filter((segment) => {
          const key = segment.sourceType === 'synthesizer'
            ? `synth-${segment.noteId}`
            : `${segment.messageIndex}-${segment.stage}-${segment.model}`;
          return !manualSegmentKeys.has(key);
        }),
      ];

      // Build payload with mode-specific fields, filtering out segments without content
      const contextSegmentPayload = combinedSegments
        .filter((segment) => segment.content) // Ensure content exists
        .map((segment) => ({
          id: segment.id,
          label: segment.label,
          content: segment.content,
          source_type: segment.sourceType || 'council',
          // Council-specific
          stage: segment.stage || null,
          model: segment.model || null,
          message_index: segment.messageIndex || null,
          // Synthesizer-specific
          note_id: segment.noteId || null,
          note_title: segment.noteTitle || null,
        }));

      const compiledContext = [
        buildHighlightsText(comments),
        buildContextStackText(combinedSegments),
      ]
        .filter(Boolean)
        .join('\n\n')
        .trim();

      // Get identifiers based on mode
      let messageIndex = null;
      let noteIds = null;

      if (isSynthesizerMode) {
        // Collect unique note IDs
        const noteIdSet = new Set();
        comments.forEach((c) => c.note_id && noteIdSet.add(c.note_id));
        combinedSegments.forEach((s) => s.noteId && noteIdSet.add(s.noteId));
        noteIds = Array.from(noteIdSet);
      } else {
        messageIndex =
          comments[0]?.message_index ??
          contextSegments[0]?.messageIndex ??
          autoContextSegments[0]?.messageIndex;

        if (messageIndex === undefined) {
          throw new Error('Unable to determine which response these context items belong to.');
        }
      }

      // Create the follow-up user message with comments context
      const followUpUserMessage = {
        role: 'follow-up-user',
        content: question,
        comments: [...comments],
        context_segments: contextSegmentPayload,
        model: model,
      };

      // Optimistically add user message to UI
      setCurrentConversation((prev) => ({
        ...prev,
        messages: [...prev.messages, followUpUserMessage],
      }));

      // Add loading placeholder for assistant response
      const followUpAssistantMessage = {
        role: 'follow-up-assistant',
        content: null,
        model: model,
        loading: true,
      };

      setCurrentConversation((prev) => ({
        ...prev,
        messages: [...prev.messages, followUpAssistantMessage],
      }));

      // Debug: log the payload being sent
      console.log('Creating thread with payload:', {
        model,
        commentIds,
        question,
        messageIndex,
        noteIds,
        contextSegments: contextSegmentPayload,
        compiledContext: compiledContext?.substring(0, 200),
      });

      // Call the API to create the thread and get response
      const thread = await api.createThread(
        currentConversationId,
        model,
        commentIds,
        question,
        {
          messageIndex,
          noteIds,
          contextSegments: contextSegmentPayload,
          compiledContext: compiledContext || null,
        }
      );

      // Update the assistant message with the actual response
      setCurrentConversation((prev) => {
        const messages = [...prev.messages];
        const lastMsg = messages[messages.length - 1];
        if (lastMsg.role === 'follow-up-assistant') {
          lastMsg.content = thread.messages[1]?.content || 'No response received';
          lastMsg.loading = false;
        }
        return { ...prev, messages };
      });

      setShowCommitSidebar(false);
      setComments([]); // Clear comments after creating thread
      setContextSegments([]);
      setActiveCommentId(null);
      setIsLoading(false);
    } catch (error) {
      console.error('Failed to start thread:', error);
      // Remove the optimistic messages on error
      setCurrentConversation((prev) => ({
        ...prev,
        messages: prev.messages.filter(m => m.role !== 'follow-up-user' && m.role !== 'follow-up-assistant'),
      }));
      setIsLoading(false);
    }
  };

  // Get available models for thread creation
  const getAvailableModels = () => {
    if (currentConversation?.council_config) {
      return currentConversation.council_config.council_models;
    }
    return availableConfig?.council_models || [];
  };

  const getDefaultChairman = () => {
    if (currentConversation?.council_config) {
      return currentConversation.council_config.chairman_model;
    }
    return availableConfig?.chairman_model;
  };

  const totalContextItems = comments.length + contextSegments.length + autoContextSegments.length;
  const hasContextItems = totalContextItems > 0;

  return (
    <div className={`app ${leftSidebarCollapsed ? 'left-collapsed' : ''} ${showCommitSidebar ? 'right-open' : ''}`}>
      <Sidebar
        conversations={conversations}
        currentConversationId={currentConversationId}
        onSelectConversation={handleSelectConversation}
        onNewConversation={handleNewConversation}
        onDeleteConversation={handleDeleteConversation}
        onOpenSettings={() => setShowSettingsModal(true)}
        onOpenSearch={() => setShowSearchModal(true)}
        collapsed={leftSidebarCollapsed}
        onToggleCollapse={() => setLeftSidebarCollapsed(!leftSidebarCollapsed)}
        isLoading={isLoading}
        animatingTitleId={animatingTitleId}
        onTitleAnimationComplete={() => setAnimatingTitleId(null)}
        promptLabels={promptLabels}
        monitors={monitors}
        currentMonitorId={currentMonitorId}
        onSelectMonitor={handleSelectMonitor}
        onPauseMonitor={handlePauseMonitor}
        onResumeMonitor={handleResumeMonitor}
        onDeleteMonitor={handleDeleteMonitor}
      />
      {currentMonitor ? (
        <MonitorInterface
          monitor={currentMonitor}
          onMonitorUpdate={(updatedMonitor) => {
            setCurrentMonitor(updatedMonitor);
            loadMonitors();
          }}
          onMarkRead={handleMarkMonitorRead}
        />
      ) : currentConversation?.mode === 'synthesizer' ? (
        <SynthesizerInterface
          conversation={currentConversation}
          onConversationUpdate={(updatedConv, newTitle) => {
            setCurrentConversation(updatedConv);
            if (newTitle) {
              // Update title in conversations list immediately and trigger animation
              setConversations((prev) =>
                prev.map((c) => (c.id === updatedConv.id ? { ...c, title: newTitle } : c))
              );
              setAnimatingTitleId(updatedConv.id);
            }
            loadConversations();
          }}
          comments={comments}
          onSelectionChange={handleSelectionChange}
          onSaveComment={handleSaveCommentDirect}
          onEditComment={handleEditComment}
          onDeleteComment={handleDeleteComment}
          activeCommentId={activeCommentId}
          onSetActiveComment={handleSetActiveComment}
        />
      ) : (
        <ChatInterface
          conversation={currentConversation}
          onSendMessage={handleSendMessage}
          isLoading={isLoading}
          comments={comments}
          contextSegments={contextSegments}
          onSelectionChange={handleSelectionChange}
          onEditComment={handleEditComment}
          onDeleteComment={handleDeleteComment}
          activeCommentId={activeCommentId}
          onSetActiveComment={handleSetActiveComment}
          onAddContextSegment={handleAddContextSegment}
          onRemoveContextSegment={handleRemoveContextSegment}
        />
      )}
      {showModeSelector && (
        <ModeSelector
          onSelect={handleModeSelect}
          onCancel={() => setShowModeSelector(false)}
        />
      )}
      <ConfigModal
        isOpen={showConfigModal}
        onClose={() => setShowConfigModal(false)}
        onSubmit={handleConfigSubmit}
        availableModels={availableConfig?.model_pool || availableConfig?.council_models}
        defaultSelectedModels={availableConfig?.council_models}
        defaultChairman={availableConfig?.chairman_model}
      />
      <SettingsModal
        isOpen={showSettingsModal}
        onClose={() => {
          setShowSettingsModal(false);
          loadConfig(); // Reload config to pick up any model changes
        }}
      />
      {showPromptManager && (
        <PromptManager
          onSelect={handlePromptSelect}
          onClose={() => {
            setShowPromptManager(false);
            setPendingCouncilConfig(null);
          }}
        />
      )}
      <CommentModal
        selection={currentSelection}
        onSave={handleSaveComment}
        onCancel={() => {
          setShowCommentModal(false);
          setCurrentSelection(null);
          setCommentButtonPosition(null);
          SelectionHandler.clearSelection();
        }}
      />
      {showCommitSidebar && (
        <CommitSidebar
          comments={comments}
          contextSegments={contextSegments}
          autoContextSegments={autoContextSegments}
          availableModels={getAvailableModels()}
          defaultChairman={getDefaultChairman()}
          onCommit={handleCommitAndStartThread}
          onClose={() => setShowCommitSidebar(false)}
          onSelectComment={handleSelectComment}
          onEditComment={handleEditComment}
          onDeleteComment={handleDeleteComment}
          showContextPreview={showContextPreview}
          onToggleContextPreview={() => setShowContextPreview(!showContextPreview)}
          activeCommentId={activeCommentId}
          onRemoveContextSegment={handleRemoveContextSegment}
        />
      )}
      {!showCommitSidebar && hasContextItems && (
        <button
          className={`commit-button-fab ${hasContextItems ? 'has-comments' : ''}`}
          onClick={handleToggleCommitSidebar}
          title="Open review context sidebar"
        >
          {`Review (${totalContextItems})`}
        </button>
      )}
      <SearchModal
        isOpen={showSearchModal}
        onClose={() => setShowSearchModal(false)}
        onSelectConversation={(id) => {
          handleSelectConversation(id);
          setShowSearchModal(false);
        }}
        onNewConversation={handleNewConversation}
        theme={theme}
        onToggleTheme={toggleTheme}
        onOpenSettings={() => {
          setShowSearchModal(false);
          setShowSettingsModal(true);
        }}
      />
    </div>
  );
}

export default App;
